%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label[cpp] \sec Nejèastìjší pøíkazy C++

\secc Pøiøazovací pøíkaz  
Použijeme, pokud chceme, aby se do promìnné uložila nìjaká data. 

Syntaxe: {\tt  datový\_typ název\_promìnné; } 
 
syntaxe vkládání: 
 
{\tt  název\_promìnné = hodnota\_která\_se\_má\_uložit; }

Data do promìnné mùžeme vložit rovnou pøi vytváøení promìnných:

 { \tt  datový\_typ název\_promìnné $=$ hodnota};

Pøíklad: { \tt  uint8\_t b = 5};  Vytvoøí se promìnná pojmenovaná { \tt  b} (která je v rozsahu od 0 do 255) a uloží se do ní èíslo { \tt  5}. 

{ \tt  int16\_t B;}  Vytvoøí se promìnná { \tt  B}. { \tt  B} není to samé jako { \tt  b}, protože jazyk C rozlišuje VELKÁ a malá písmena. 

{ \tt  B $=$ 1024;}  Do promìnné B se uloží hodnota 1024;

\secc{Blok pøíkazù} 
Pokud chceme nìkam dát více pøíkazù, ale mùžeme tam dát pouze jeden pøíkaz, tak je dáme do složených závorek
Pøíklad: 
 
\hisyntax{C} \begtt 
{
  PØÍKAZ1;
  PØÍKAZ2;
  PØÍKAZ3;
}
\endtt


\label[if] \secc{Podmiòovací pøíkaz if }

\ii if Použijeme, pokud chceme, aby se program mohl rozhodnout na základì nìjaké podmínky. \ii else
 
syntaxe:

\hisyntax{C} \begtt 
if(PODMÍNKA)
  PØÍKAZ1;
else
  PØÍKAZ2;
\endtt

Pokud platí { \tt  PODMÍNKA} v kulaté závorce, vykoná se { \tt  PØÍKAZ1}, pokud neplatí, vykoná se { \tt  PØÍKAZ2}.
Za { \tt  if} nebo { \tt  else} mùže být pouze jeden pøíkaz, pokud jich tam chceme dát více, použijeme blok.
Vìtev { \tt  else} je nepovinná.

Pøíklad:
\hisyntax{C} \begtt 
if(a > 5) // Pokud platí, že 
          //promìnná a je vìtší nìž 5, tak se
{
  b = a;  // do promìnné b uloží hodnota, která je v promìnné a
  c = 2;  // do promìnné c se uloží èíslo 2.
} // Pokud podmínka neplatí, tak se nevykoná nic.
\endtt

podmínka mùže být výraz napø.: 
\hisyntax{C} \begtt 
a > 5 // podmínka bude platit, 
      // pokud promìnná a je vìtší než 5
\endtt
podmínìné pøíkazy lze vnoøovat - v bloku pøíkazù mùže být další if
Pøíklad:
\hisyntax{C} \begtt 
if(PODMÍNKA1)
{
  PØÍKAZ1;
  if(PODMÍNKA2)
  {
    PØÍKAZ2;
  }
  PØÍKAZ3;
}
else 
{
  PØÍKAZ4;
}
\endtt

Pokud platí { \tt  PODMÍNKA1} tak se vykoná { \tt  PØÍKAZ1}, pak se zkontroluje { \tt  PODMÍNKA2}, pokud platí, tak se vykoná { \tt  PØÍKAZ2}, pokud ne, program pokraèuje dál a vykoná { \tt  PØÍKAZ3}.
V pøípadì, že neplatí ani { \tt  PODMÍNKA1}, tak se blok pøíkazù pøeskoèí a vykoná se blok pøíkazù za { \tt  else}, tj. { \tt  PØÍKAZ4}.

Je tu možnost také do vìtve { \tt  else} napsat daší { \tt  if else}, vypadá to takto:
\hisyntax{C} \begtt 
if(PODMÍNKA1)
{
  PRÍKAZ1;
}
else
{
  if(PODMÍNKA2)
  {
    PRÍKAZ2;
  }
  else
  {
    PRÍKAZ3;
  }
}
\endtt
Pokud platí { \tt  PODMÍNKA1}, tak se vykoná { \tt  PØÍKAZ1}, pokud ne, tak se zkontroluje { \tt  PODMÍNKA2}, pokud platí tak se vykoná { \tt  PØÍKAZ2}, pokud neplatí, tak se vykoná { \tt  PØÍKAZ3}. Výše zapsaný kód sice bude fungovat, ale není pøehledný, a proto z dùvodu lepší orientace v kódu zvolíme tento zápis:
\hisyntax{C} \begtt 
if(PODMÍNKA1)
{
  PRÍKAZ1;
}
else if(PODMÍNKA2)
{
  PRÍKAZ2;
}
else
{
  PRÍKAZ3;
}
\endtt

\secc{Pøíkaz nìkolikanásobného vìtvení }

Pokud by takto zapsaných podmínek bylo moc a vztahovali by se k jedné øídící promìnné lze použít pøíkaz nìkolikanásobného vìtvìní neboli {\tt switch}. \ii switch Tak napøíklad místo zápisu:

\hisyntax{C} \begtt 
if(a == 1)
{
  PØÍKAZ1;
}
else if(a == 2)
{
  PØÍKAZ2;
}
else if(a == 3)
{
  PØÍKAZ3;
}
else if(a == 4)
{
  PØÍKAZ4;
}
else
{
  PØÍKAZ5;
}
\endtt
Lze napsat:
\hisyntax{C} \begtt 
switch(a)
{
  case 1:
    PØÍKAZ1;
    break;
  case 2:
    PØÍKAZ2;
    break;
  case 3:
    PØÍKAZ3;
    break;
  case 4:
    PØÍKAZ4;
    break;
  default:
    PØÍKAZ5;
    break;
}
\endtt
Èím se to celé zjednodušuje.

\secc{Cyklus for (cyklus øízený promìnou )} 

\ii for Tento cyklu použijeme, pokud pøedem známe kolikrát se má opakovat urèitá operace
Syntaxe:
\hisyntax{C} \begtt 
for(øidící_promìnná; podmínka; zvýšení_nebo_snížení_hodnoty_promìnné )
{
  PØÍKAZ1;
  PØÍKAZ2;
}
\endtt

Pøíklad:
\hisyntax{C} \begtt 
for(uint8_t i=0; i<4; i++)
{
  rozsvit_ledku();
  pockej_sekundu();
  zhasni ledku();
}
\endtt
Co tento kód udìlá? Dejme tomu, že máme už pøedem vytvoøené funkce { \tt  rozsvit\_ledku()}, atd... Potom cyklus udìlá následující: vytvoøí promìnnou { \tt  i} datového typu { \tt  uint8\_t} (celá èísla od { \tt  0} do { \tt  255}), uloží do ní èíslo { \tt  0}. Potom zkontroluje podmínku, zda je promìnná { \tt  i} menší než { \tt  4}, pak se provedou pøíkazy èi funkce v tìle cyklu, tj. rozsvítí se LED, bude svítit jednu sekundu, a pak zhasne. Pak se provede pøíkaz { \tt  i++}, ten zvýší hodnotu promìnné o jednu, tj. na èíslo { \tt  1}. Potom se kontroluje znovu podmínka, zdali je promìnná { \tt  i} (která má teï hodnotu { \tt  1}) menší než { \tt  4}, atd... Celkem se tìlo cyklu vykoná ètyøikrát.

Cyklus { \tt  for} lze použít i bez promìnné, podmínky a zvýšení hodnoty, potom bude probíhat donekoneèna.
Pøíklad:
{ \tt  for(;;)}
\hisyntax{C} \begtt 
{
  rozsvit_ledku();
  pockej_sekundu();
  zhasni ledku();
}
\endtt 
Tento cyklus bude dìlat to samé, co pøedchozí, s tím rozdílem, že to bude dìlat donekoneèna a nebude se ptát na podmínku. 

Použití v programu pro robota: Nekoneèný cyklus, ve kterém se kontrolují podmínky, zda je na èáøe, zda je pøed ním soupeø, zda má udìlat to èi ono.


\secc{Cyklus while (cyklus s podmínkou na zaèátku )} 

\ii while Použijeme, pokud nebudeme vìdìt kolikrát mají probìhnout pøíkazy a funkce v tìle cyklu.
Syntaxe:

\hisyntax{C} \begtt 
while(podmínka)
{
  PØÍKAZ1;
  ...
}
\endtt


Pøíklad:
\hisyntax{C} \begtt 
while(!je_tlacitko_stiskle())
{
  ujed_1_cm();
}
\endtt

Tento cyklus bude stát, dokud nezmáèkneme tlaèítko. Vyžaduje mít pøedem naprogramovanou funkci { \tt  ujed\_1\_cm()} a { \tt  je\_tlacitko\_stiskle()}.

 
%%%%%%%%%%%%%% Napsat cyklus do-while 
  
\sec{Funkce a procedury} 

 Pokud se nám v zdrojovém kódu opakují dokola stejné pøíkazy, mùžeme vytvoøit \iid funkce nebo procedury, které potom voláme a které nám usnadní kód.
syntaxe:
\hisyntax{C} \begtt 
datový_typ_který_funkce_vrací název_funkce(datový_typ_parametru1 
parametr1, datový_typ_parametru2 parametr2) 
// Parametry jsou nepovinné
{
  PØÍKAZ1; // Nepovinné pøíkazy
  PØÍKAZ2;
  return HODNOTA_KTEROU_FUNKCE_VRACI; 
  // Za return se napíše výraz, který funkce vrací.
}
\endtt \ii return

Pøíklad:
\hisyntax{C} \begtt 
// Funkce na sèítání dvou èísel, každé od 0 do 255.
uint16_t umocni(uint8_t zakl, uint8_t exp)
{
  uint16_t vys = 1;
  if(exp > 0)
  {
    for(uint8_t i = 0; i < exp; i++)
    {
      vys = vys * zakl; 
    }
  }
  return vys;
}
\endtt

pokud nìkde v programu použiji funkci { \tt  secti(10, 2)}, tak výsledkem bude, jako bych napsal { \tt  10*10}, tj. { \tt  100}.
Pøíklad:
\hisyntax{C} \begtt 
c = umocni(a, b); // Do promìnné c se uloží b-tá mocnina èísla a. 
\endtt

\iid procedura -- je vlastnì funkce, jen s tím rozdílem, že procedura má datový typ { \tt  void} \ii void  
a nemá { \tt  return} (tj. nevrací žádnou hodnotu).

Pøíklad:
\hisyntax{C} \begtt 
void rozsvitLedku()
{
  DDRB |= (1<<PB0); /* Co dìlá tento pøíkaz nemusíte zatím øešit,
   pak se k tomu dostaneme.
   */
}
\endtt

Pokud nìkde v programu napíšu { \tt  rozsvitLedku()}, tak se rozsvítí LEDka na robotovi.

Celý program v C++ tvoøí funkce \iid main -- všechny pøíkazy, které jsou mezi složenými závorkami, se po zahajení programu postupnì vykonají. 

\sec{Knihovny}

\secc{Vlastní knihovny}
Z funkcí a procedur se mohou vytváøet soubory pro usnadnìní práce. tìmto souborùm se øíká {\bf knihovny}. \ii knihovna Soubory mají koncovku {\it .h}
Pøíklad: { \tt  avr/io.h}
{ \tt  moje\_knihovna.h}

Vlastní knihovnu poté mohu vložit direktivou { \tt  \#include}
Pøíklad:
\hisyntax{C} \begtt 
#include "moje_knihovna.h"
\endtt 

\secc{Použité knihovny}  

Pro práci s èipy budeme potøebovat nìkteré už vytvoøené knihovny

Pøíklad: 

%{ \tt  avr/io.h}  -- pro základní vstup a výstup

%{ \tt  avr/interrupt.h} -- pro práci s pøerušením

{ \tt  Arduino.h} -- zavádí pøíkazy pro práci s èipy ATMega a ESP32

{ \tt  Learningkit.h}  -- pro pohodlnou práci s deskou ALKS

{ \tt  stdint.h}  -- zde je definovány \link[ref:datovy_typ]{\Magenta}{datové typy}\Black   

 
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
